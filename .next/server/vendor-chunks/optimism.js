"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/optimism";
exports.ids = ["vendor-chunks/optimism"];
exports.modules = {

/***/ "(ssr)/./node_modules/optimism/lib/bundle.cjs":
/*!**********************************************!*\
  !*** ./node_modules/optimism/lib/bundle.cjs ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar trie = __webpack_require__(/*! @wry/trie */ \"(ssr)/./node_modules/@wry/trie/lib/bundle.cjs\");\nvar caches$1 = __webpack_require__(/*! @wry/caches */ \"(ssr)/./node_modules/@wry/caches/lib/bundle.cjs\");\nvar context = __webpack_require__(/*! @wry/context */ \"(ssr)/./node_modules/@wry/context/lib/bundle.cjs\");\n\nvar parentEntrySlot = new context.Slot();\nfunction nonReactive(fn) {\n    return parentEntrySlot.withValue(void 0, fn);\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar arrayFromSet = Array.from ||\n    function (set) {\n        var array = [];\n        set.forEach(function (item) { return array.push(item); });\n        return array;\n    };\nfunction maybeUnsubscribe(entryOrDep) {\n    var unsubscribe = entryOrDep.unsubscribe;\n    if (typeof unsubscribe === \"function\") {\n        entryOrDep.unsubscribe = void 0;\n        unsubscribe();\n    }\n}\n\nvar emptySetPool = [];\nvar POOL_TARGET_SIZE = 100;\n// Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\nfunction assert(condition, optionalMessage) {\n    if (!condition) {\n        throw new Error(optionalMessage || \"assertion failure\");\n    }\n}\nfunction valueIs(a, b) {\n    var len = a.length;\n    return (\n    // Unknown values are not equal to each other.\n    len > 0 &&\n        // Both values must be ordinary (or both exceptional) to be equal.\n        len === b.length &&\n        // The underlying value or exception must be the same.\n        a[len - 1] === b[len - 1]);\n}\nfunction valueGet(value) {\n    switch (value.length) {\n        case 0: throw new Error(\"unknown value\");\n        case 1: return value[0];\n        case 2: throw value[1];\n    }\n}\nfunction valueCopy(value) {\n    return value.slice(0);\n}\nvar Entry = /** @class */ (function () {\n    function Entry(fn) {\n        this.fn = fn;\n        this.parents = new Set();\n        this.childValues = new Map();\n        // When this Entry has children that are dirty, this property becomes\n        // a Set containing other Entry objects, borrowed from emptySetPool.\n        // When the set becomes empty, it gets recycled back to emptySetPool.\n        this.dirtyChildren = null;\n        this.dirty = true;\n        this.recomputing = false;\n        this.value = [];\n        this.deps = null;\n        ++Entry.count;\n    }\n    Entry.prototype.peek = function () {\n        if (this.value.length === 1 && !mightBeDirty(this)) {\n            rememberParent(this);\n            return this.value[0];\n        }\n    };\n    // This is the most important method of the Entry API, because it\n    // determines whether the cached this.value can be returned immediately,\n    // or must be recomputed. The overall performance of the caching system\n    // depends on the truth of the following observations: (1) this.dirty is\n    // usually false, (2) this.dirtyChildren is usually null/empty, and thus\n    // (3) valueGet(this.value) is usually returned without recomputation.\n    Entry.prototype.recompute = function (args) {\n        assert(!this.recomputing, \"already recomputing\");\n        rememberParent(this);\n        return mightBeDirty(this)\n            ? reallyRecompute(this, args)\n            : valueGet(this.value);\n    };\n    Entry.prototype.setDirty = function () {\n        if (this.dirty)\n            return;\n        this.dirty = true;\n        reportDirty(this);\n        // We can go ahead and unsubscribe here, since any further dirty\n        // notifications we receive will be redundant, and unsubscribing may\n        // free up some resources, e.g. file watchers.\n        maybeUnsubscribe(this);\n    };\n    Entry.prototype.dispose = function () {\n        var _this = this;\n        this.setDirty();\n        // Sever any dependency relationships with our own children, so those\n        // children don't retain this parent Entry in their child.parents sets,\n        // thereby preventing it from being fully garbage collected.\n        forgetChildren(this);\n        // Because this entry has been kicked out of the cache (in index.js),\n        // we've lost the ability to find out if/when this entry becomes dirty,\n        // whether that happens through a subscription, because of a direct call\n        // to entry.setDirty(), or because one of its children becomes dirty.\n        // Because of this loss of future information, we have to assume the\n        // worst (that this entry might have become dirty very soon), so we must\n        // immediately mark this entry's parents as dirty. Normally we could\n        // just call entry.setDirty() rather than calling parent.setDirty() for\n        // each parent, but that would leave this entry in parent.childValues\n        // and parent.dirtyChildren, which would prevent the child from being\n        // truly forgotten.\n        eachParent(this, function (parent, child) {\n            parent.setDirty();\n            forgetChild(parent, _this);\n        });\n    };\n    Entry.prototype.forget = function () {\n        // The code that creates Entry objects in index.ts will replace this method\n        // with one that actually removes the Entry from the cache, which will also\n        // trigger the entry.dispose method.\n        this.dispose();\n    };\n    Entry.prototype.dependOn = function (dep) {\n        dep.add(this);\n        if (!this.deps) {\n            this.deps = emptySetPool.pop() || new Set();\n        }\n        this.deps.add(dep);\n    };\n    Entry.prototype.forgetDeps = function () {\n        var _this = this;\n        if (this.deps) {\n            arrayFromSet(this.deps).forEach(function (dep) { return dep.delete(_this); });\n            this.deps.clear();\n            emptySetPool.push(this.deps);\n            this.deps = null;\n        }\n    };\n    Entry.count = 0;\n    return Entry;\n}());\nfunction rememberParent(child) {\n    var parent = parentEntrySlot.getValue();\n    if (parent) {\n        child.parents.add(parent);\n        if (!parent.childValues.has(child)) {\n            parent.childValues.set(child, []);\n        }\n        if (mightBeDirty(child)) {\n            reportDirtyChild(parent, child);\n        }\n        else {\n            reportCleanChild(parent, child);\n        }\n        return parent;\n    }\n}\nfunction reallyRecompute(entry, args) {\n    forgetChildren(entry);\n    // Set entry as the parent entry while calling recomputeNewValue(entry).\n    parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);\n    if (maybeSubscribe(entry, args)) {\n        // If we successfully recomputed entry.value and did not fail to\n        // (re)subscribe, then this Entry is no longer explicitly dirty.\n        setClean(entry);\n    }\n    return valueGet(entry.value);\n}\nfunction recomputeNewValue(entry, args) {\n    entry.recomputing = true;\n    var normalizeResult = entry.normalizeResult;\n    var oldValueCopy;\n    if (normalizeResult && entry.value.length === 1) {\n        oldValueCopy = valueCopy(entry.value);\n    }\n    // Make entry.value an empty array, representing an unknown value.\n    entry.value.length = 0;\n    try {\n        // If entry.fn succeeds, entry.value will become a normal Value.\n        entry.value[0] = entry.fn.apply(null, args);\n        // If we have a viable oldValueCopy to compare with the (successfully\n        // recomputed) new entry.value, and they are not already === identical, give\n        // normalizeResult a chance to pick/choose/reuse parts of oldValueCopy[0]\n        // and/or entry.value[0] to determine the final cached entry.value.\n        if (normalizeResult && oldValueCopy && !valueIs(oldValueCopy, entry.value)) {\n            try {\n                entry.value[0] = normalizeResult(entry.value[0], oldValueCopy[0]);\n            }\n            catch (_a) {\n                // If normalizeResult throws, just use the newer value, rather than\n                // saving the exception as entry.value[1].\n            }\n        }\n    }\n    catch (e) {\n        // If entry.fn throws, entry.value will hold that exception.\n        entry.value[1] = e;\n    }\n    // Either way, this line is always reached.\n    entry.recomputing = false;\n}\nfunction mightBeDirty(entry) {\n    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\n}\nfunction setClean(entry) {\n    entry.dirty = false;\n    if (mightBeDirty(entry)) {\n        // This Entry may still have dirty children, in which case we can't\n        // let our parents know we're clean just yet.\n        return;\n    }\n    reportClean(entry);\n}\nfunction reportDirty(child) {\n    eachParent(child, reportDirtyChild);\n}\nfunction reportClean(child) {\n    eachParent(child, reportCleanChild);\n}\nfunction eachParent(child, callback) {\n    var parentCount = child.parents.size;\n    if (parentCount) {\n        var parents = arrayFromSet(child.parents);\n        for (var i = 0; i < parentCount; ++i) {\n            callback(parents[i], child);\n        }\n    }\n}\n// Let a parent Entry know that one of its children may be dirty.\nfunction reportDirtyChild(parent, child) {\n    // Must have called rememberParent(child) before calling\n    // reportDirtyChild(parent, child).\n    assert(parent.childValues.has(child));\n    assert(mightBeDirty(child));\n    var parentWasClean = !mightBeDirty(parent);\n    if (!parent.dirtyChildren) {\n        parent.dirtyChildren = emptySetPool.pop() || new Set;\n    }\n    else if (parent.dirtyChildren.has(child)) {\n        // If we already know this child is dirty, then we must have already\n        // informed our own parents that we are dirty, so we can terminate\n        // the recursion early.\n        return;\n    }\n    parent.dirtyChildren.add(child);\n    // If parent was clean before, it just became (possibly) dirty (according to\n    // mightBeDirty), since we just added child to parent.dirtyChildren.\n    if (parentWasClean) {\n        reportDirty(parent);\n    }\n}\n// Let a parent Entry know that one of its children is no longer dirty.\nfunction reportCleanChild(parent, child) {\n    // Must have called rememberChild(child) before calling\n    // reportCleanChild(parent, child).\n    assert(parent.childValues.has(child));\n    assert(!mightBeDirty(child));\n    var childValue = parent.childValues.get(child);\n    if (childValue.length === 0) {\n        parent.childValues.set(child, valueCopy(child.value));\n    }\n    else if (!valueIs(childValue, child.value)) {\n        parent.setDirty();\n    }\n    removeDirtyChild(parent, child);\n    if (mightBeDirty(parent)) {\n        return;\n    }\n    reportClean(parent);\n}\nfunction removeDirtyChild(parent, child) {\n    var dc = parent.dirtyChildren;\n    if (dc) {\n        dc.delete(child);\n        if (dc.size === 0) {\n            if (emptySetPool.length < POOL_TARGET_SIZE) {\n                emptySetPool.push(dc);\n            }\n            parent.dirtyChildren = null;\n        }\n    }\n}\n// Removes all children from this entry and returns an array of the\n// removed children.\nfunction forgetChildren(parent) {\n    if (parent.childValues.size > 0) {\n        parent.childValues.forEach(function (_value, child) {\n            forgetChild(parent, child);\n        });\n    }\n    // Remove this parent Entry from any sets to which it was added by the\n    // addToSet method.\n    parent.forgetDeps();\n    // After we forget all our children, this.dirtyChildren must be empty\n    // and therefore must have been reset to null.\n    assert(parent.dirtyChildren === null);\n}\nfunction forgetChild(parent, child) {\n    child.parents.delete(parent);\n    parent.childValues.delete(child);\n    removeDirtyChild(parent, child);\n}\nfunction maybeSubscribe(entry, args) {\n    if (typeof entry.subscribe === \"function\") {\n        try {\n            maybeUnsubscribe(entry); // Prevent double subscriptions.\n            entry.unsubscribe = entry.subscribe.apply(null, args);\n        }\n        catch (e) {\n            // If this Entry has a subscribe function and it threw an exception\n            // (or an unsubscribe function it previously returned now throws),\n            // return false to indicate that we were not able to subscribe (or\n            // unsubscribe), and this Entry should remain dirty.\n            entry.setDirty();\n            return false;\n        }\n    }\n    // Returning true indicates either that there was no entry.subscribe\n    // function or that it succeeded.\n    return true;\n}\n\nvar EntryMethods = {\n    setDirty: true,\n    dispose: true,\n    forget: true, // Fully remove parent Entry from LRU cache and computation graph\n};\nfunction dep(options) {\n    var depsByKey = new Map();\n    var subscribe = options && options.subscribe;\n    function depend(key) {\n        var parent = parentEntrySlot.getValue();\n        if (parent) {\n            var dep_1 = depsByKey.get(key);\n            if (!dep_1) {\n                depsByKey.set(key, dep_1 = new Set);\n            }\n            parent.dependOn(dep_1);\n            if (typeof subscribe === \"function\") {\n                maybeUnsubscribe(dep_1);\n                dep_1.unsubscribe = subscribe(key);\n            }\n        }\n    }\n    depend.dirty = function dirty(key, entryMethodName) {\n        var dep = depsByKey.get(key);\n        if (dep) {\n            var m_1 = (entryMethodName &&\n                hasOwnProperty.call(EntryMethods, entryMethodName)) ? entryMethodName : \"setDirty\";\n            // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\n            // because modifying a Set while iterating over it can cause elements in\n            // the Set to be removed from the Set before they've been iterated over.\n            arrayFromSet(dep).forEach(function (entry) { return entry[m_1](); });\n            depsByKey.delete(key);\n            maybeUnsubscribe(dep);\n        }\n    };\n    return depend;\n}\n\n// The defaultMakeCacheKey function is remarkably powerful, because it gives\n// a unique object for any shallow-identical list of arguments. If you need\n// to implement a custom makeCacheKey function, you may find it helpful to\n// delegate the final work to defaultMakeCacheKey, which is why we export it\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\n// does not support WeakMap, or you have the ability to return a string key.\n// In those cases, just write your own custom makeCacheKey functions.\nvar defaultKeyTrie;\nfunction defaultMakeCacheKey() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var trie$1 = defaultKeyTrie || (defaultKeyTrie = new trie.Trie(typeof WeakMap === \"function\"));\n    return trie$1.lookupArray(args);\n}\nvar caches = new Set();\nfunction wrap(originalFunction, _a) {\n    var _b = _a === void 0 ? Object.create(null) : _a, _c = _b.max, max = _c === void 0 ? Math.pow(2, 16) : _c, keyArgs = _b.keyArgs, _d = _b.makeCacheKey, makeCacheKey = _d === void 0 ? defaultMakeCacheKey : _d, normalizeResult = _b.normalizeResult, subscribe = _b.subscribe, _e = _b.cache, cacheOption = _e === void 0 ? caches$1.StrongCache : _e;\n    var cache = typeof cacheOption === \"function\"\n        ? new cacheOption(max, function (entry) { return entry.dispose(); })\n        : cacheOption;\n    var optimistic = function () {\n        var key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);\n        if (key === void 0) {\n            return originalFunction.apply(null, arguments);\n        }\n        var entry = cache.get(key);\n        if (!entry) {\n            cache.set(key, entry = new Entry(originalFunction));\n            entry.normalizeResult = normalizeResult;\n            entry.subscribe = subscribe;\n            // Give the Entry the ability to trigger cache.delete(key), even though\n            // the Entry itself does not know about key or cache.\n            entry.forget = function () { return cache.delete(key); };\n        }\n        var value = entry.recompute(Array.prototype.slice.call(arguments));\n        // Move this entry to the front of the least-recently used queue,\n        // since we just finished computing its value.\n        cache.set(key, entry);\n        caches.add(cache);\n        // Clean up any excess entries in the cache, but only if there is no\n        // active parent entry, meaning we're not in the middle of a larger\n        // computation that might be flummoxed by the cleaning.\n        if (!parentEntrySlot.hasValue()) {\n            caches.forEach(function (cache) { return cache.clean(); });\n            caches.clear();\n        }\n        return value;\n    };\n    Object.defineProperty(optimistic, \"size\", {\n        get: function () { return cache.size; },\n        configurable: false,\n        enumerable: false,\n    });\n    Object.freeze(optimistic.options = {\n        max: max,\n        keyArgs: keyArgs,\n        makeCacheKey: makeCacheKey,\n        normalizeResult: normalizeResult,\n        subscribe: subscribe,\n        cache: cache,\n    });\n    function dirtyKey(key) {\n        var entry = key && cache.get(key);\n        if (entry) {\n            entry.setDirty();\n        }\n    }\n    optimistic.dirtyKey = dirtyKey;\n    optimistic.dirty = function dirty() {\n        dirtyKey(makeCacheKey.apply(null, arguments));\n    };\n    function peekKey(key) {\n        var entry = key && cache.get(key);\n        if (entry) {\n            return entry.peek();\n        }\n    }\n    optimistic.peekKey = peekKey;\n    optimistic.peek = function peek() {\n        return peekKey(makeCacheKey.apply(null, arguments));\n    };\n    function forgetKey(key) {\n        return key ? cache.delete(key) : false;\n    }\n    optimistic.forgetKey = forgetKey;\n    optimistic.forget = function forget() {\n        return forgetKey(makeCacheKey.apply(null, arguments));\n    };\n    optimistic.makeCacheKey = makeCacheKey;\n    optimistic.getKey = keyArgs ? function getKey() {\n        return makeCacheKey.apply(null, keyArgs.apply(null, arguments));\n    } : makeCacheKey;\n    return Object.freeze(optimistic);\n}\n\nObject.defineProperty(exports, \"KeyTrie\", ({\n    enumerable: true,\n    get: function () { return trie.Trie; }\n}));\nObject.defineProperty(exports, \"Slot\", ({\n    enumerable: true,\n    get: function () { return context.Slot; }\n}));\nObject.defineProperty(exports, \"asyncFromGen\", ({\n    enumerable: true,\n    get: function () { return context.asyncFromGen; }\n}));\nObject.defineProperty(exports, \"bindContext\", ({\n    enumerable: true,\n    get: function () { return context.bind; }\n}));\nObject.defineProperty(exports, \"noContext\", ({\n    enumerable: true,\n    get: function () { return context.noContext; }\n}));\nObject.defineProperty(exports, \"setTimeout\", ({\n    enumerable: true,\n    get: function () { return context.setTimeout; }\n}));\nexports.defaultMakeCacheKey = defaultMakeCacheKey;\nexports.dep = dep;\nexports.nonReactive = nonReactive;\nexports.wrap = wrap;\n//# sourceMappingURL=bundle.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3B0aW1pc20vbGliL2J1bmRsZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGdFQUFXO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyxvRUFBYTtBQUNwQyxjQUFjLG1CQUFPLENBQUMsc0VBQWM7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDBCQUEwQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCwyQkFBMkI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsc0JBQXNCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHlCQUF5QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1QkFBdUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSwyQ0FBMEM7QUFDMUM7QUFDQSx1QkFBdUI7QUFDdkIsQ0FBQyxFQUFDO0FBQ0Ysd0NBQXVDO0FBQ3ZDO0FBQ0EsdUJBQXVCO0FBQ3ZCLENBQUMsRUFBQztBQUNGLGdEQUErQztBQUMvQztBQUNBLHVCQUF1QjtBQUN2QixDQUFDLEVBQUM7QUFDRiwrQ0FBOEM7QUFDOUM7QUFDQSx1QkFBdUI7QUFDdkIsQ0FBQyxFQUFDO0FBQ0YsNkNBQTRDO0FBQzVDO0FBQ0EsdUJBQXVCO0FBQ3ZCLENBQUMsRUFBQztBQUNGLDhDQUE2QztBQUM3QztBQUNBLHVCQUF1QjtBQUN2QixDQUFDLEVBQUM7QUFDRiwyQkFBMkI7QUFDM0IsV0FBVztBQUNYLG1CQUFtQjtBQUNuQixZQUFZO0FBQ1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvb3B0aW1pc20vbGliL2J1bmRsZS5janM/NWQyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB0cmllID0gcmVxdWlyZSgnQHdyeS90cmllJyk7XG52YXIgY2FjaGVzJDEgPSByZXF1aXJlKCdAd3J5L2NhY2hlcycpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCdAd3J5L2NvbnRleHQnKTtcblxudmFyIHBhcmVudEVudHJ5U2xvdCA9IG5ldyBjb250ZXh0LlNsb3QoKTtcbmZ1bmN0aW9uIG5vblJlYWN0aXZlKGZuKSB7XG4gICAgcmV0dXJuIHBhcmVudEVudHJ5U2xvdC53aXRoVmFsdWUodm9pZCAwLCBmbik7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgYXJyYXlGcm9tU2V0ID0gQXJyYXkuZnJvbSB8fFxuICAgIGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBhcnJheS5wdXNoKGl0ZW0pOyB9KTtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH07XG5mdW5jdGlvbiBtYXliZVVuc3Vic2NyaWJlKGVudHJ5T3JEZXApIHtcbiAgICB2YXIgdW5zdWJzY3JpYmUgPSBlbnRyeU9yRGVwLnVuc3Vic2NyaWJlO1xuICAgIGlmICh0eXBlb2YgdW5zdWJzY3JpYmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBlbnRyeU9yRGVwLnVuc3Vic2NyaWJlID0gdm9pZCAwO1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgIH1cbn1cblxudmFyIGVtcHR5U2V0UG9vbCA9IFtdO1xudmFyIFBPT0xfVEFSR0VUX1NJWkUgPSAxMDA7XG4vLyBTaW5jZSB0aGlzIHBhY2thZ2UgbWlnaHQgYmUgdXNlZCBicm93c2Vycywgd2Ugc2hvdWxkIGF2b2lkIHVzaW5nIHRoZVxuLy8gTm9kZSBidWlsdC1pbiBhc3NlcnQgbW9kdWxlLlxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgb3B0aW9uYWxNZXNzYWdlKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG9wdGlvbmFsTWVzc2FnZSB8fCBcImFzc2VydGlvbiBmYWlsdXJlXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbHVlSXMoYSwgYikge1xuICAgIHZhciBsZW4gPSBhLmxlbmd0aDtcbiAgICByZXR1cm4gKFxuICAgIC8vIFVua25vd24gdmFsdWVzIGFyZSBub3QgZXF1YWwgdG8gZWFjaCBvdGhlci5cbiAgICBsZW4gPiAwICYmXG4gICAgICAgIC8vIEJvdGggdmFsdWVzIG11c3QgYmUgb3JkaW5hcnkgKG9yIGJvdGggZXhjZXB0aW9uYWwpIHRvIGJlIGVxdWFsLlxuICAgICAgICBsZW4gPT09IGIubGVuZ3RoICYmXG4gICAgICAgIC8vIFRoZSB1bmRlcmx5aW5nIHZhbHVlIG9yIGV4Y2VwdGlvbiBtdXN0IGJlIHRoZSBzYW1lLlxuICAgICAgICBhW2xlbiAtIDFdID09PSBiW2xlbiAtIDFdKTtcbn1cbmZ1bmN0aW9uIHZhbHVlR2V0KHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOiB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHZhbHVlXCIpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiB2YWx1ZVswXTtcbiAgICAgICAgY2FzZSAyOiB0aHJvdyB2YWx1ZVsxXTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWx1ZUNvcHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc2xpY2UoMCk7XG59XG52YXIgRW50cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW50cnkoZm4pIHtcbiAgICAgICAgdGhpcy5mbiA9IGZuO1xuICAgICAgICB0aGlzLnBhcmVudHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuY2hpbGRWYWx1ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIFdoZW4gdGhpcyBFbnRyeSBoYXMgY2hpbGRyZW4gdGhhdCBhcmUgZGlydHksIHRoaXMgcHJvcGVydHkgYmVjb21lc1xuICAgICAgICAvLyBhIFNldCBjb250YWluaW5nIG90aGVyIEVudHJ5IG9iamVjdHMsIGJvcnJvd2VkIGZyb20gZW1wdHlTZXRQb29sLlxuICAgICAgICAvLyBXaGVuIHRoZSBzZXQgYmVjb21lcyBlbXB0eSwgaXQgZ2V0cyByZWN5Y2xlZCBiYWNrIHRvIGVtcHR5U2V0UG9vbC5cbiAgICAgICAgdGhpcy5kaXJ0eUNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMucmVjb21wdXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICB0aGlzLmRlcHMgPSBudWxsO1xuICAgICAgICArK0VudHJ5LmNvdW50O1xuICAgIH1cbiAgICBFbnRyeS5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID09PSAxICYmICFtaWdodEJlRGlydHkodGhpcykpIHtcbiAgICAgICAgICAgIHJlbWVtYmVyUGFyZW50KHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVbMF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFRoaXMgaXMgdGhlIG1vc3QgaW1wb3J0YW50IG1ldGhvZCBvZiB0aGUgRW50cnkgQVBJLCBiZWNhdXNlIGl0XG4gICAgLy8gZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjYWNoZWQgdGhpcy52YWx1ZSBjYW4gYmUgcmV0dXJuZWQgaW1tZWRpYXRlbHksXG4gICAgLy8gb3IgbXVzdCBiZSByZWNvbXB1dGVkLiBUaGUgb3ZlcmFsbCBwZXJmb3JtYW5jZSBvZiB0aGUgY2FjaGluZyBzeXN0ZW1cbiAgICAvLyBkZXBlbmRzIG9uIHRoZSB0cnV0aCBvZiB0aGUgZm9sbG93aW5nIG9ic2VydmF0aW9uczogKDEpIHRoaXMuZGlydHkgaXNcbiAgICAvLyB1c3VhbGx5IGZhbHNlLCAoMikgdGhpcy5kaXJ0eUNoaWxkcmVuIGlzIHVzdWFsbHkgbnVsbC9lbXB0eSwgYW5kIHRodXNcbiAgICAvLyAoMykgdmFsdWVHZXQodGhpcy52YWx1ZSkgaXMgdXN1YWxseSByZXR1cm5lZCB3aXRob3V0IHJlY29tcHV0YXRpb24uXG4gICAgRW50cnkucHJvdG90eXBlLnJlY29tcHV0ZSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIGFzc2VydCghdGhpcy5yZWNvbXB1dGluZywgXCJhbHJlYWR5IHJlY29tcHV0aW5nXCIpO1xuICAgICAgICByZW1lbWJlclBhcmVudCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG1pZ2h0QmVEaXJ0eSh0aGlzKVxuICAgICAgICAgICAgPyByZWFsbHlSZWNvbXB1dGUodGhpcywgYXJncylcbiAgICAgICAgICAgIDogdmFsdWVHZXQodGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICBFbnRyeS5wcm90b3R5cGUuc2V0RGlydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgcmVwb3J0RGlydHkodGhpcyk7XG4gICAgICAgIC8vIFdlIGNhbiBnbyBhaGVhZCBhbmQgdW5zdWJzY3JpYmUgaGVyZSwgc2luY2UgYW55IGZ1cnRoZXIgZGlydHlcbiAgICAgICAgLy8gbm90aWZpY2F0aW9ucyB3ZSByZWNlaXZlIHdpbGwgYmUgcmVkdW5kYW50LCBhbmQgdW5zdWJzY3JpYmluZyBtYXlcbiAgICAgICAgLy8gZnJlZSB1cCBzb21lIHJlc291cmNlcywgZS5nLiBmaWxlIHdhdGNoZXJzLlxuICAgICAgICBtYXliZVVuc3Vic2NyaWJlKHRoaXMpO1xuICAgIH07XG4gICAgRW50cnkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc2V0RGlydHkoKTtcbiAgICAgICAgLy8gU2V2ZXIgYW55IGRlcGVuZGVuY3kgcmVsYXRpb25zaGlwcyB3aXRoIG91ciBvd24gY2hpbGRyZW4sIHNvIHRob3NlXG4gICAgICAgIC8vIGNoaWxkcmVuIGRvbid0IHJldGFpbiB0aGlzIHBhcmVudCBFbnRyeSBpbiB0aGVpciBjaGlsZC5wYXJlbnRzIHNldHMsXG4gICAgICAgIC8vIHRoZXJlYnkgcHJldmVudGluZyBpdCBmcm9tIGJlaW5nIGZ1bGx5IGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgICAgICBmb3JnZXRDaGlsZHJlbih0aGlzKTtcbiAgICAgICAgLy8gQmVjYXVzZSB0aGlzIGVudHJ5IGhhcyBiZWVuIGtpY2tlZCBvdXQgb2YgdGhlIGNhY2hlIChpbiBpbmRleC5qcyksXG4gICAgICAgIC8vIHdlJ3ZlIGxvc3QgdGhlIGFiaWxpdHkgdG8gZmluZCBvdXQgaWYvd2hlbiB0aGlzIGVudHJ5IGJlY29tZXMgZGlydHksXG4gICAgICAgIC8vIHdoZXRoZXIgdGhhdCBoYXBwZW5zIHRocm91Z2ggYSBzdWJzY3JpcHRpb24sIGJlY2F1c2Ugb2YgYSBkaXJlY3QgY2FsbFxuICAgICAgICAvLyB0byBlbnRyeS5zZXREaXJ0eSgpLCBvciBiZWNhdXNlIG9uZSBvZiBpdHMgY2hpbGRyZW4gYmVjb21lcyBkaXJ0eS5cbiAgICAgICAgLy8gQmVjYXVzZSBvZiB0aGlzIGxvc3Mgb2YgZnV0dXJlIGluZm9ybWF0aW9uLCB3ZSBoYXZlIHRvIGFzc3VtZSB0aGVcbiAgICAgICAgLy8gd29yc3QgKHRoYXQgdGhpcyBlbnRyeSBtaWdodCBoYXZlIGJlY29tZSBkaXJ0eSB2ZXJ5IHNvb24pLCBzbyB3ZSBtdXN0XG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IG1hcmsgdGhpcyBlbnRyeSdzIHBhcmVudHMgYXMgZGlydHkuIE5vcm1hbGx5IHdlIGNvdWxkXG4gICAgICAgIC8vIGp1c3QgY2FsbCBlbnRyeS5zZXREaXJ0eSgpIHJhdGhlciB0aGFuIGNhbGxpbmcgcGFyZW50LnNldERpcnR5KCkgZm9yXG4gICAgICAgIC8vIGVhY2ggcGFyZW50LCBidXQgdGhhdCB3b3VsZCBsZWF2ZSB0aGlzIGVudHJ5IGluIHBhcmVudC5jaGlsZFZhbHVlc1xuICAgICAgICAvLyBhbmQgcGFyZW50LmRpcnR5Q2hpbGRyZW4sIHdoaWNoIHdvdWxkIHByZXZlbnQgdGhlIGNoaWxkIGZyb20gYmVpbmdcbiAgICAgICAgLy8gdHJ1bHkgZm9yZ290dGVuLlxuICAgICAgICBlYWNoUGFyZW50KHRoaXMsIGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkKSB7XG4gICAgICAgICAgICBwYXJlbnQuc2V0RGlydHkoKTtcbiAgICAgICAgICAgIGZvcmdldENoaWxkKHBhcmVudCwgX3RoaXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEVudHJ5LnByb3RvdHlwZS5mb3JnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRoZSBjb2RlIHRoYXQgY3JlYXRlcyBFbnRyeSBvYmplY3RzIGluIGluZGV4LnRzIHdpbGwgcmVwbGFjZSB0aGlzIG1ldGhvZFxuICAgICAgICAvLyB3aXRoIG9uZSB0aGF0IGFjdHVhbGx5IHJlbW92ZXMgdGhlIEVudHJ5IGZyb20gdGhlIGNhY2hlLCB3aGljaCB3aWxsIGFsc29cbiAgICAgICAgLy8gdHJpZ2dlciB0aGUgZW50cnkuZGlzcG9zZSBtZXRob2QuXG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgRW50cnkucHJvdG90eXBlLmRlcGVuZE9uID0gZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICBkZXAuYWRkKHRoaXMpO1xuICAgICAgICBpZiAoIXRoaXMuZGVwcykge1xuICAgICAgICAgICAgdGhpcy5kZXBzID0gZW1wdHlTZXRQb29sLnBvcCgpIHx8IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlcHMuYWRkKGRlcCk7XG4gICAgfTtcbiAgICBFbnRyeS5wcm90b3R5cGUuZm9yZ2V0RGVwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZGVwcykge1xuICAgICAgICAgICAgYXJyYXlGcm9tU2V0KHRoaXMuZGVwcykuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBkZXAuZGVsZXRlKF90aGlzKTsgfSk7XG4gICAgICAgICAgICB0aGlzLmRlcHMuY2xlYXIoKTtcbiAgICAgICAgICAgIGVtcHR5U2V0UG9vbC5wdXNoKHRoaXMuZGVwcyk7XG4gICAgICAgICAgICB0aGlzLmRlcHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbnRyeS5jb3VudCA9IDA7XG4gICAgcmV0dXJuIEVudHJ5O1xufSgpKTtcbmZ1bmN0aW9uIHJlbWVtYmVyUGFyZW50KGNoaWxkKSB7XG4gICAgdmFyIHBhcmVudCA9IHBhcmVudEVudHJ5U2xvdC5nZXRWYWx1ZSgpO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgY2hpbGQucGFyZW50cy5hZGQocGFyZW50KTtcbiAgICAgICAgaWYgKCFwYXJlbnQuY2hpbGRWYWx1ZXMuaGFzKGNoaWxkKSkge1xuICAgICAgICAgICAgcGFyZW50LmNoaWxkVmFsdWVzLnNldChjaGlsZCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaWdodEJlRGlydHkoY2hpbGQpKSB7XG4gICAgICAgICAgICByZXBvcnREaXJ0eUNoaWxkKHBhcmVudCwgY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVwb3J0Q2xlYW5DaGlsZChwYXJlbnQsIGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlYWxseVJlY29tcHV0ZShlbnRyeSwgYXJncykge1xuICAgIGZvcmdldENoaWxkcmVuKGVudHJ5KTtcbiAgICAvLyBTZXQgZW50cnkgYXMgdGhlIHBhcmVudCBlbnRyeSB3aGlsZSBjYWxsaW5nIHJlY29tcHV0ZU5ld1ZhbHVlKGVudHJ5KS5cbiAgICBwYXJlbnRFbnRyeVNsb3Qud2l0aFZhbHVlKGVudHJ5LCByZWNvbXB1dGVOZXdWYWx1ZSwgW2VudHJ5LCBhcmdzXSk7XG4gICAgaWYgKG1heWJlU3Vic2NyaWJlKGVudHJ5LCBhcmdzKSkge1xuICAgICAgICAvLyBJZiB3ZSBzdWNjZXNzZnVsbHkgcmVjb21wdXRlZCBlbnRyeS52YWx1ZSBhbmQgZGlkIG5vdCBmYWlsIHRvXG4gICAgICAgIC8vIChyZSlzdWJzY3JpYmUsIHRoZW4gdGhpcyBFbnRyeSBpcyBubyBsb25nZXIgZXhwbGljaXRseSBkaXJ0eS5cbiAgICAgICAgc2V0Q2xlYW4oZW50cnkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVHZXQoZW50cnkudmFsdWUpO1xufVxuZnVuY3Rpb24gcmVjb21wdXRlTmV3VmFsdWUoZW50cnksIGFyZ3MpIHtcbiAgICBlbnRyeS5yZWNvbXB1dGluZyA9IHRydWU7XG4gICAgdmFyIG5vcm1hbGl6ZVJlc3VsdCA9IGVudHJ5Lm5vcm1hbGl6ZVJlc3VsdDtcbiAgICB2YXIgb2xkVmFsdWVDb3B5O1xuICAgIGlmIChub3JtYWxpemVSZXN1bHQgJiYgZW50cnkudmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG9sZFZhbHVlQ29weSA9IHZhbHVlQ29weShlbnRyeS52YWx1ZSk7XG4gICAgfVxuICAgIC8vIE1ha2UgZW50cnkudmFsdWUgYW4gZW1wdHkgYXJyYXksIHJlcHJlc2VudGluZyBhbiB1bmtub3duIHZhbHVlLlxuICAgIGVudHJ5LnZhbHVlLmxlbmd0aCA9IDA7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gSWYgZW50cnkuZm4gc3VjY2VlZHMsIGVudHJ5LnZhbHVlIHdpbGwgYmVjb21lIGEgbm9ybWFsIFZhbHVlLlxuICAgICAgICBlbnRyeS52YWx1ZVswXSA9IGVudHJ5LmZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgdmlhYmxlIG9sZFZhbHVlQ29weSB0byBjb21wYXJlIHdpdGggdGhlIChzdWNjZXNzZnVsbHlcbiAgICAgICAgLy8gcmVjb21wdXRlZCkgbmV3IGVudHJ5LnZhbHVlLCBhbmQgdGhleSBhcmUgbm90IGFscmVhZHkgPT09IGlkZW50aWNhbCwgZ2l2ZVxuICAgICAgICAvLyBub3JtYWxpemVSZXN1bHQgYSBjaGFuY2UgdG8gcGljay9jaG9vc2UvcmV1c2UgcGFydHMgb2Ygb2xkVmFsdWVDb3B5WzBdXG4gICAgICAgIC8vIGFuZC9vciBlbnRyeS52YWx1ZVswXSB0byBkZXRlcm1pbmUgdGhlIGZpbmFsIGNhY2hlZCBlbnRyeS52YWx1ZS5cbiAgICAgICAgaWYgKG5vcm1hbGl6ZVJlc3VsdCAmJiBvbGRWYWx1ZUNvcHkgJiYgIXZhbHVlSXMob2xkVmFsdWVDb3B5LCBlbnRyeS52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZW50cnkudmFsdWVbMF0gPSBub3JtYWxpemVSZXN1bHQoZW50cnkudmFsdWVbMF0sIG9sZFZhbHVlQ29weVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBub3JtYWxpemVSZXN1bHQgdGhyb3dzLCBqdXN0IHVzZSB0aGUgbmV3ZXIgdmFsdWUsIHJhdGhlciB0aGFuXG4gICAgICAgICAgICAgICAgLy8gc2F2aW5nIHRoZSBleGNlcHRpb24gYXMgZW50cnkudmFsdWVbMV0uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSWYgZW50cnkuZm4gdGhyb3dzLCBlbnRyeS52YWx1ZSB3aWxsIGhvbGQgdGhhdCBleGNlcHRpb24uXG4gICAgICAgIGVudHJ5LnZhbHVlWzFdID0gZTtcbiAgICB9XG4gICAgLy8gRWl0aGVyIHdheSwgdGhpcyBsaW5lIGlzIGFsd2F5cyByZWFjaGVkLlxuICAgIGVudHJ5LnJlY29tcHV0aW5nID0gZmFsc2U7XG59XG5mdW5jdGlvbiBtaWdodEJlRGlydHkoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuZGlydHkgfHwgISEoZW50cnkuZGlydHlDaGlsZHJlbiAmJiBlbnRyeS5kaXJ0eUNoaWxkcmVuLnNpemUpO1xufVxuZnVuY3Rpb24gc2V0Q2xlYW4oZW50cnkpIHtcbiAgICBlbnRyeS5kaXJ0eSA9IGZhbHNlO1xuICAgIGlmIChtaWdodEJlRGlydHkoZW50cnkpKSB7XG4gICAgICAgIC8vIFRoaXMgRW50cnkgbWF5IHN0aWxsIGhhdmUgZGlydHkgY2hpbGRyZW4sIGluIHdoaWNoIGNhc2Ugd2UgY2FuJ3RcbiAgICAgICAgLy8gbGV0IG91ciBwYXJlbnRzIGtub3cgd2UncmUgY2xlYW4ganVzdCB5ZXQuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVwb3J0Q2xlYW4oZW50cnkpO1xufVxuZnVuY3Rpb24gcmVwb3J0RGlydHkoY2hpbGQpIHtcbiAgICBlYWNoUGFyZW50KGNoaWxkLCByZXBvcnREaXJ0eUNoaWxkKTtcbn1cbmZ1bmN0aW9uIHJlcG9ydENsZWFuKGNoaWxkKSB7XG4gICAgZWFjaFBhcmVudChjaGlsZCwgcmVwb3J0Q2xlYW5DaGlsZCk7XG59XG5mdW5jdGlvbiBlYWNoUGFyZW50KGNoaWxkLCBjYWxsYmFjaykge1xuICAgIHZhciBwYXJlbnRDb3VudCA9IGNoaWxkLnBhcmVudHMuc2l6ZTtcbiAgICBpZiAocGFyZW50Q291bnQpIHtcbiAgICAgICAgdmFyIHBhcmVudHMgPSBhcnJheUZyb21TZXQoY2hpbGQucGFyZW50cyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgY2FsbGJhY2socGFyZW50c1tpXSwgY2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gTGV0IGEgcGFyZW50IEVudHJ5IGtub3cgdGhhdCBvbmUgb2YgaXRzIGNoaWxkcmVuIG1heSBiZSBkaXJ0eS5cbmZ1bmN0aW9uIHJlcG9ydERpcnR5Q2hpbGQocGFyZW50LCBjaGlsZCkge1xuICAgIC8vIE11c3QgaGF2ZSBjYWxsZWQgcmVtZW1iZXJQYXJlbnQoY2hpbGQpIGJlZm9yZSBjYWxsaW5nXG4gICAgLy8gcmVwb3J0RGlydHlDaGlsZChwYXJlbnQsIGNoaWxkKS5cbiAgICBhc3NlcnQocGFyZW50LmNoaWxkVmFsdWVzLmhhcyhjaGlsZCkpO1xuICAgIGFzc2VydChtaWdodEJlRGlydHkoY2hpbGQpKTtcbiAgICB2YXIgcGFyZW50V2FzQ2xlYW4gPSAhbWlnaHRCZURpcnR5KHBhcmVudCk7XG4gICAgaWYgKCFwYXJlbnQuZGlydHlDaGlsZHJlbikge1xuICAgICAgICBwYXJlbnQuZGlydHlDaGlsZHJlbiA9IGVtcHR5U2V0UG9vbC5wb3AoKSB8fCBuZXcgU2V0O1xuICAgIH1cbiAgICBlbHNlIGlmIChwYXJlbnQuZGlydHlDaGlsZHJlbi5oYXMoY2hpbGQpKSB7XG4gICAgICAgIC8vIElmIHdlIGFscmVhZHkga25vdyB0aGlzIGNoaWxkIGlzIGRpcnR5LCB0aGVuIHdlIG11c3QgaGF2ZSBhbHJlYWR5XG4gICAgICAgIC8vIGluZm9ybWVkIG91ciBvd24gcGFyZW50cyB0aGF0IHdlIGFyZSBkaXJ0eSwgc28gd2UgY2FuIHRlcm1pbmF0ZVxuICAgICAgICAvLyB0aGUgcmVjdXJzaW9uIGVhcmx5LlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHBhcmVudC5kaXJ0eUNoaWxkcmVuLmFkZChjaGlsZCk7XG4gICAgLy8gSWYgcGFyZW50IHdhcyBjbGVhbiBiZWZvcmUsIGl0IGp1c3QgYmVjYW1lIChwb3NzaWJseSkgZGlydHkgKGFjY29yZGluZyB0b1xuICAgIC8vIG1pZ2h0QmVEaXJ0eSksIHNpbmNlIHdlIGp1c3QgYWRkZWQgY2hpbGQgdG8gcGFyZW50LmRpcnR5Q2hpbGRyZW4uXG4gICAgaWYgKHBhcmVudFdhc0NsZWFuKSB7XG4gICAgICAgIHJlcG9ydERpcnR5KHBhcmVudCk7XG4gICAgfVxufVxuLy8gTGV0IGEgcGFyZW50IEVudHJ5IGtub3cgdGhhdCBvbmUgb2YgaXRzIGNoaWxkcmVuIGlzIG5vIGxvbmdlciBkaXJ0eS5cbmZ1bmN0aW9uIHJlcG9ydENsZWFuQ2hpbGQocGFyZW50LCBjaGlsZCkge1xuICAgIC8vIE11c3QgaGF2ZSBjYWxsZWQgcmVtZW1iZXJDaGlsZChjaGlsZCkgYmVmb3JlIGNhbGxpbmdcbiAgICAvLyByZXBvcnRDbGVhbkNoaWxkKHBhcmVudCwgY2hpbGQpLlxuICAgIGFzc2VydChwYXJlbnQuY2hpbGRWYWx1ZXMuaGFzKGNoaWxkKSk7XG4gICAgYXNzZXJ0KCFtaWdodEJlRGlydHkoY2hpbGQpKTtcbiAgICB2YXIgY2hpbGRWYWx1ZSA9IHBhcmVudC5jaGlsZFZhbHVlcy5nZXQoY2hpbGQpO1xuICAgIGlmIChjaGlsZFZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBwYXJlbnQuY2hpbGRWYWx1ZXMuc2V0KGNoaWxkLCB2YWx1ZUNvcHkoY2hpbGQudmFsdWUpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXZhbHVlSXMoY2hpbGRWYWx1ZSwgY2hpbGQudmFsdWUpKSB7XG4gICAgICAgIHBhcmVudC5zZXREaXJ0eSgpO1xuICAgIH1cbiAgICByZW1vdmVEaXJ0eUNoaWxkKHBhcmVudCwgY2hpbGQpO1xuICAgIGlmIChtaWdodEJlRGlydHkocGFyZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlcG9ydENsZWFuKHBhcmVudCk7XG59XG5mdW5jdGlvbiByZW1vdmVEaXJ0eUNoaWxkKHBhcmVudCwgY2hpbGQpIHtcbiAgICB2YXIgZGMgPSBwYXJlbnQuZGlydHlDaGlsZHJlbjtcbiAgICBpZiAoZGMpIHtcbiAgICAgICAgZGMuZGVsZXRlKGNoaWxkKTtcbiAgICAgICAgaWYgKGRjLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChlbXB0eVNldFBvb2wubGVuZ3RoIDwgUE9PTF9UQVJHRVRfU0laRSkge1xuICAgICAgICAgICAgICAgIGVtcHR5U2V0UG9vbC5wdXNoKGRjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5kaXJ0eUNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhpcyBlbnRyeSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVcbi8vIHJlbW92ZWQgY2hpbGRyZW4uXG5mdW5jdGlvbiBmb3JnZXRDaGlsZHJlbihwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmNoaWxkVmFsdWVzLnNpemUgPiAwKSB7XG4gICAgICAgIHBhcmVudC5jaGlsZFZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIChfdmFsdWUsIGNoaWxkKSB7XG4gICAgICAgICAgICBmb3JnZXRDaGlsZChwYXJlbnQsIGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGlzIHBhcmVudCBFbnRyeSBmcm9tIGFueSBzZXRzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBieSB0aGVcbiAgICAvLyBhZGRUb1NldCBtZXRob2QuXG4gICAgcGFyZW50LmZvcmdldERlcHMoKTtcbiAgICAvLyBBZnRlciB3ZSBmb3JnZXQgYWxsIG91ciBjaGlsZHJlbiwgdGhpcy5kaXJ0eUNoaWxkcmVuIG11c3QgYmUgZW1wdHlcbiAgICAvLyBhbmQgdGhlcmVmb3JlIG11c3QgaGF2ZSBiZWVuIHJlc2V0IHRvIG51bGwuXG4gICAgYXNzZXJ0KHBhcmVudC5kaXJ0eUNoaWxkcmVuID09PSBudWxsKTtcbn1cbmZ1bmN0aW9uIGZvcmdldENoaWxkKHBhcmVudCwgY2hpbGQpIHtcbiAgICBjaGlsZC5wYXJlbnRzLmRlbGV0ZShwYXJlbnQpO1xuICAgIHBhcmVudC5jaGlsZFZhbHVlcy5kZWxldGUoY2hpbGQpO1xuICAgIHJlbW92ZURpcnR5Q2hpbGQocGFyZW50LCBjaGlsZCk7XG59XG5mdW5jdGlvbiBtYXliZVN1YnNjcmliZShlbnRyeSwgYXJncykge1xuICAgIGlmICh0eXBlb2YgZW50cnkuc3Vic2NyaWJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1heWJlVW5zdWJzY3JpYmUoZW50cnkpOyAvLyBQcmV2ZW50IGRvdWJsZSBzdWJzY3JpcHRpb25zLlxuICAgICAgICAgICAgZW50cnkudW5zdWJzY3JpYmUgPSBlbnRyeS5zdWJzY3JpYmUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgRW50cnkgaGFzIGEgc3Vic2NyaWJlIGZ1bmN0aW9uIGFuZCBpdCB0aHJldyBhbiBleGNlcHRpb25cbiAgICAgICAgICAgIC8vIChvciBhbiB1bnN1YnNjcmliZSBmdW5jdGlvbiBpdCBwcmV2aW91c2x5IHJldHVybmVkIG5vdyB0aHJvd3MpLFxuICAgICAgICAgICAgLy8gcmV0dXJuIGZhbHNlIHRvIGluZGljYXRlIHRoYXQgd2Ugd2VyZSBub3QgYWJsZSB0byBzdWJzY3JpYmUgKG9yXG4gICAgICAgICAgICAvLyB1bnN1YnNjcmliZSksIGFuZCB0aGlzIEVudHJ5IHNob3VsZCByZW1haW4gZGlydHkuXG4gICAgICAgICAgICBlbnRyeS5zZXREaXJ0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJldHVybmluZyB0cnVlIGluZGljYXRlcyBlaXRoZXIgdGhhdCB0aGVyZSB3YXMgbm8gZW50cnkuc3Vic2NyaWJlXG4gICAgLy8gZnVuY3Rpb24gb3IgdGhhdCBpdCBzdWNjZWVkZWQuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBFbnRyeU1ldGhvZHMgPSB7XG4gICAgc2V0RGlydHk6IHRydWUsXG4gICAgZGlzcG9zZTogdHJ1ZSxcbiAgICBmb3JnZXQ6IHRydWUsIC8vIEZ1bGx5IHJlbW92ZSBwYXJlbnQgRW50cnkgZnJvbSBMUlUgY2FjaGUgYW5kIGNvbXB1dGF0aW9uIGdyYXBoXG59O1xuZnVuY3Rpb24gZGVwKG9wdGlvbnMpIHtcbiAgICB2YXIgZGVwc0J5S2V5ID0gbmV3IE1hcCgpO1xuICAgIHZhciBzdWJzY3JpYmUgPSBvcHRpb25zICYmIG9wdGlvbnMuc3Vic2NyaWJlO1xuICAgIGZ1bmN0aW9uIGRlcGVuZChrZXkpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHBhcmVudEVudHJ5U2xvdC5nZXRWYWx1ZSgpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgZGVwXzEgPSBkZXBzQnlLZXkuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAoIWRlcF8xKSB7XG4gICAgICAgICAgICAgICAgZGVwc0J5S2V5LnNldChrZXksIGRlcF8xID0gbmV3IFNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQuZGVwZW5kT24oZGVwXzEpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpYmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG1heWJlVW5zdWJzY3JpYmUoZGVwXzEpO1xuICAgICAgICAgICAgICAgIGRlcF8xLnVuc3Vic2NyaWJlID0gc3Vic2NyaWJlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVwZW5kLmRpcnR5ID0gZnVuY3Rpb24gZGlydHkoa2V5LCBlbnRyeU1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIGRlcCA9IGRlcHNCeUtleS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGRlcCkge1xuICAgICAgICAgICAgdmFyIG1fMSA9IChlbnRyeU1ldGhvZE5hbWUgJiZcbiAgICAgICAgICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKEVudHJ5TWV0aG9kcywgZW50cnlNZXRob2ROYW1lKSkgPyBlbnRyeU1ldGhvZE5hbWUgOiBcInNldERpcnR5XCI7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHRvIHVzZSBhcnJheUZyb21TZXQoZGVwKS5mb3JFYWNoIGluc3RlYWQgb2YgZGVwLmZvckVhY2gsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIG1vZGlmeWluZyBhIFNldCB3aGlsZSBpdGVyYXRpbmcgb3ZlciBpdCBjYW4gY2F1c2UgZWxlbWVudHMgaW5cbiAgICAgICAgICAgIC8vIHRoZSBTZXQgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBTZXQgYmVmb3JlIHRoZXkndmUgYmVlbiBpdGVyYXRlZCBvdmVyLlxuICAgICAgICAgICAgYXJyYXlGcm9tU2V0KGRlcCkuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5W21fMV0oKTsgfSk7XG4gICAgICAgICAgICBkZXBzQnlLZXkuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICBtYXliZVVuc3Vic2NyaWJlKGRlcCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBkZXBlbmQ7XG59XG5cbi8vIFRoZSBkZWZhdWx0TWFrZUNhY2hlS2V5IGZ1bmN0aW9uIGlzIHJlbWFya2FibHkgcG93ZXJmdWwsIGJlY2F1c2UgaXQgZ2l2ZXNcbi8vIGEgdW5pcXVlIG9iamVjdCBmb3IgYW55IHNoYWxsb3ctaWRlbnRpY2FsIGxpc3Qgb2YgYXJndW1lbnRzLiBJZiB5b3UgbmVlZFxuLy8gdG8gaW1wbGVtZW50IGEgY3VzdG9tIG1ha2VDYWNoZUtleSBmdW5jdGlvbiwgeW91IG1heSBmaW5kIGl0IGhlbHBmdWwgdG9cbi8vIGRlbGVnYXRlIHRoZSBmaW5hbCB3b3JrIHRvIGRlZmF1bHRNYWtlQ2FjaGVLZXksIHdoaWNoIGlzIHdoeSB3ZSBleHBvcnQgaXRcbi8vIGhlcmUuIEhvd2V2ZXIsIHlvdSBtYXkgd2FudCB0byBhdm9pZCBkZWZhdWx0TWFrZUNhY2hlS2V5IGlmIHlvdXIgcnVudGltZVxuLy8gZG9lcyBub3Qgc3VwcG9ydCBXZWFrTWFwLCBvciB5b3UgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXR1cm4gYSBzdHJpbmcga2V5LlxuLy8gSW4gdGhvc2UgY2FzZXMsIGp1c3Qgd3JpdGUgeW91ciBvd24gY3VzdG9tIG1ha2VDYWNoZUtleSBmdW5jdGlvbnMuXG52YXIgZGVmYXVsdEtleVRyaWU7XG5mdW5jdGlvbiBkZWZhdWx0TWFrZUNhY2hlS2V5KCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgdHJpZSQxID0gZGVmYXVsdEtleVRyaWUgfHwgKGRlZmF1bHRLZXlUcmllID0gbmV3IHRyaWUuVHJpZSh0eXBlb2YgV2Vha01hcCA9PT0gXCJmdW5jdGlvblwiKSk7XG4gICAgcmV0dXJuIHRyaWUkMS5sb29rdXBBcnJheShhcmdzKTtcbn1cbnZhciBjYWNoZXMgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiB3cmFwKG9yaWdpbmFsRnVuY3Rpb24sIF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBfYSwgX2MgPSBfYi5tYXgsIG1heCA9IF9jID09PSB2b2lkIDAgPyBNYXRoLnBvdygyLCAxNikgOiBfYywga2V5QXJncyA9IF9iLmtleUFyZ3MsIF9kID0gX2IubWFrZUNhY2hlS2V5LCBtYWtlQ2FjaGVLZXkgPSBfZCA9PT0gdm9pZCAwID8gZGVmYXVsdE1ha2VDYWNoZUtleSA6IF9kLCBub3JtYWxpemVSZXN1bHQgPSBfYi5ub3JtYWxpemVSZXN1bHQsIHN1YnNjcmliZSA9IF9iLnN1YnNjcmliZSwgX2UgPSBfYi5jYWNoZSwgY2FjaGVPcHRpb24gPSBfZSA9PT0gdm9pZCAwID8gY2FjaGVzJDEuU3Ryb25nQ2FjaGUgOiBfZTtcbiAgICB2YXIgY2FjaGUgPSB0eXBlb2YgY2FjaGVPcHRpb24gPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IG5ldyBjYWNoZU9wdGlvbihtYXgsIGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkuZGlzcG9zZSgpOyB9KVxuICAgICAgICA6IGNhY2hlT3B0aW9uO1xuICAgIHZhciBvcHRpbWlzdGljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIga2V5ID0gbWFrZUNhY2hlS2V5LmFwcGx5KG51bGwsIGtleUFyZ3MgPyBrZXlBcmdzLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgOiBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoa2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEZ1bmN0aW9uLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgICAgIGNhY2hlLnNldChrZXksIGVudHJ5ID0gbmV3IEVudHJ5KG9yaWdpbmFsRnVuY3Rpb24pKTtcbiAgICAgICAgICAgIGVudHJ5Lm5vcm1hbGl6ZVJlc3VsdCA9IG5vcm1hbGl6ZVJlc3VsdDtcbiAgICAgICAgICAgIGVudHJ5LnN1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICAgICAgICAgIC8vIEdpdmUgdGhlIEVudHJ5IHRoZSBhYmlsaXR5IHRvIHRyaWdnZXIgY2FjaGUuZGVsZXRlKGtleSksIGV2ZW4gdGhvdWdoXG4gICAgICAgICAgICAvLyB0aGUgRW50cnkgaXRzZWxmIGRvZXMgbm90IGtub3cgYWJvdXQga2V5IG9yIGNhY2hlLlxuICAgICAgICAgICAgZW50cnkuZm9yZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FjaGUuZGVsZXRlKGtleSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gZW50cnkucmVjb21wdXRlKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAvLyBNb3ZlIHRoaXMgZW50cnkgdG8gdGhlIGZyb250IG9mIHRoZSBsZWFzdC1yZWNlbnRseSB1c2VkIHF1ZXVlLFxuICAgICAgICAvLyBzaW5jZSB3ZSBqdXN0IGZpbmlzaGVkIGNvbXB1dGluZyBpdHMgdmFsdWUuXG4gICAgICAgIGNhY2hlLnNldChrZXksIGVudHJ5KTtcbiAgICAgICAgY2FjaGVzLmFkZChjYWNoZSk7XG4gICAgICAgIC8vIENsZWFuIHVwIGFueSBleGNlc3MgZW50cmllcyBpbiB0aGUgY2FjaGUsIGJ1dCBvbmx5IGlmIHRoZXJlIGlzIG5vXG4gICAgICAgIC8vIGFjdGl2ZSBwYXJlbnQgZW50cnksIG1lYW5pbmcgd2UncmUgbm90IGluIHRoZSBtaWRkbGUgb2YgYSBsYXJnZXJcbiAgICAgICAgLy8gY29tcHV0YXRpb24gdGhhdCBtaWdodCBiZSBmbHVtbW94ZWQgYnkgdGhlIGNsZWFuaW5nLlxuICAgICAgICBpZiAoIXBhcmVudEVudHJ5U2xvdC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBjYWNoZXMuZm9yRWFjaChmdW5jdGlvbiAoY2FjaGUpIHsgcmV0dXJuIGNhY2hlLmNsZWFuKCk7IH0pO1xuICAgICAgICAgICAgY2FjaGVzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdGltaXN0aWMsIFwic2l6ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FjaGUuc2l6ZTsgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgfSk7XG4gICAgT2JqZWN0LmZyZWV6ZShvcHRpbWlzdGljLm9wdGlvbnMgPSB7XG4gICAgICAgIG1heDogbWF4LFxuICAgICAgICBrZXlBcmdzOiBrZXlBcmdzLFxuICAgICAgICBtYWtlQ2FjaGVLZXk6IG1ha2VDYWNoZUtleSxcbiAgICAgICAgbm9ybWFsaXplUmVzdWx0OiBub3JtYWxpemVSZXN1bHQsXG4gICAgICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxuICAgICAgICBjYWNoZTogY2FjaGUsXG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZGlydHlLZXkoa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGtleSAmJiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBlbnRyeS5zZXREaXJ0eSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9wdGltaXN0aWMuZGlydHlLZXkgPSBkaXJ0eUtleTtcbiAgICBvcHRpbWlzdGljLmRpcnR5ID0gZnVuY3Rpb24gZGlydHkoKSB7XG4gICAgICAgIGRpcnR5S2V5KG1ha2VDYWNoZUtleS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBlZWtLZXkoa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGtleSAmJiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkucGVlaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9wdGltaXN0aWMucGVla0tleSA9IHBlZWtLZXk7XG4gICAgb3B0aW1pc3RpYy5wZWVrID0gZnVuY3Rpb24gcGVlaygpIHtcbiAgICAgICAgcmV0dXJuIHBlZWtLZXkobWFrZUNhY2hlS2V5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZm9yZ2V0S2V5KGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8gY2FjaGUuZGVsZXRlKGtleSkgOiBmYWxzZTtcbiAgICB9XG4gICAgb3B0aW1pc3RpYy5mb3JnZXRLZXkgPSBmb3JnZXRLZXk7XG4gICAgb3B0aW1pc3RpYy5mb3JnZXQgPSBmdW5jdGlvbiBmb3JnZXQoKSB7XG4gICAgICAgIHJldHVybiBmb3JnZXRLZXkobWFrZUNhY2hlS2V5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgb3B0aW1pc3RpYy5tYWtlQ2FjaGVLZXkgPSBtYWtlQ2FjaGVLZXk7XG4gICAgb3B0aW1pc3RpYy5nZXRLZXkgPSBrZXlBcmdzID8gZnVuY3Rpb24gZ2V0S2V5KCkge1xuICAgICAgICByZXR1cm4gbWFrZUNhY2hlS2V5LmFwcGx5KG51bGwsIGtleUFyZ3MuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgfSA6IG1ha2VDYWNoZUtleTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShvcHRpbWlzdGljKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdLZXlUcmllJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmllLlRyaWU7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTbG90Jywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250ZXh0LlNsb3Q7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdhc3luY0Zyb21HZW4nLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRleHQuYXN5bmNGcm9tR2VuOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnYmluZENvbnRleHQnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRleHQuYmluZDsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ25vQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udGV4dC5ub0NvbnRleHQ7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdzZXRUaW1lb3V0Jywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250ZXh0LnNldFRpbWVvdXQ7IH1cbn0pO1xuZXhwb3J0cy5kZWZhdWx0TWFrZUNhY2hlS2V5ID0gZGVmYXVsdE1ha2VDYWNoZUtleTtcbmV4cG9ydHMuZGVwID0gZGVwO1xuZXhwb3J0cy5ub25SZWFjdGl2ZSA9IG5vblJlYWN0aXZlO1xuZXhwb3J0cy53cmFwID0gd3JhcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bmRsZS5janMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/optimism/lib/bundle.cjs\n");

/***/ })

};
;